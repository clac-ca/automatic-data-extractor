#!/usr/bin/env python3
"""
Standalone ADE smoke test aligned with the developer guide.

This script exercises the end-to-end "prepare" flow described in
docs/developers/README.md by:

1. Creating ADE_DATA_DIR subfolders (config_packages, .venv, jobs, documents, cache/pip).
  2. Seeding config_packages/<config_id>/ with a realistic sample config (manifest, .env,
     site-packages/ade_config) if it is empty.
  3. Creating a dedicated virtual environment for that config (python -m venv).
  4. Installing requirements.txt (includes openpyxl) into the venv, sharing a pip cache,
     and capturing install.log for cache verification.
5. Copying manifest.json and .env into .venv/<config_id>/ade-runtime/ for diagnostics.
  6. Copying everything under config_packages/<config_id>/site-packages/ into the venv's
     site-packages and marking it read-only.
  7. Emitting packages.txt (pip freeze) and build.json (hashes, versions, prepared_at metadata).
  8. Launching the venv interpreter with -I -B to confirm imports resolve from the installed config code.
  9. Repeating the workflow for multiple config IDs to confirm pip cache hits on subsequent prepares.

Only Python's standard library is used so the script can run anywhere. The output
mirrors what a real ADE "prepare" step would leave on disk, which makes it a good
sanity check before wiring up the full API/worker stack.
"""

from __future__ import annotations

import argparse
import hashlib
import json
import os
import shutil
import subprocess
import sys
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from textwrap import dedent

READ_ONLY_FILE_MODE = 0o444
READ_ONLY_DIR_MODE = 0o555
IGNORED_NAMES = {".git", "__pycache__"}
IGNORED_SUFFIXES = {".pyc", ".pyo", "~"}


@dataclass(frozen=True)
class ADEPaths:
    data_root: Path
    config_id: str

    @property
    def config_dir(self) -> Path:
        return self.data_root / "config_packages" / self.config_id

    @property
    def venv_dir(self) -> Path:
        return self.data_root / ".venv" / self.config_id

    @property
    def runtime_dir(self) -> Path:
        return self.venv_dir / "ade-runtime"

    @property
    def pip_cache_dir(self) -> Path:
        return self.data_root / "cache" / "pip"

    @property
    def install_log_path(self) -> Path:
        return self.runtime_dir / "install.log"

    @property
    def packages_txt_path(self) -> Path:
        return self.runtime_dir / "packages.txt"

    @property
    def build_json_path(self) -> Path:
        return self.runtime_dir / "build.json"

    @property
    def manifest_runtime_path(self) -> Path:
        return self.runtime_dir / "manifest.json"

    @property
    def config_env_runtime_path(self) -> Path:
        return self.runtime_dir / "config.env"

    def venv_python(self) -> Path:
        folder = "Scripts" if os.name == "nt" else "bin"
        executable = "python.exe" if os.name == "nt" else "python"
        return self.venv_dir / folder / executable


def _log(stage: str, message: str) -> None:
    print(f"[{stage}] {message}")


def ensure_data_roots(paths: ADEPaths) -> None:
    for sub in ("config_packages", ".venv", "jobs", "documents", "cache/pip"):
        target = paths.data_root / sub
        target.mkdir(parents=True, exist_ok=True)


def ensure_sample_config(paths: ADEPaths, *, dependencies: tuple[str, ...] = ("openpyxl>=3.1.2",)) -> None:
    cfg_dir = paths.config_dir
    if cfg_dir.exists() and any(cfg_dir.iterdir()):
        return

    _log("demo", f"seeding sample config at {cfg_dir}")
    site_packages = cfg_dir / "site-packages" / "ade_config"
    row_detectors = site_packages / "row_detectors"
    row_detectors.mkdir(parents=True, exist_ok=True)
    (site_packages / "__init__.py").write_text(
        "__all__ = ['row_detectors']\n",
        encoding="utf-8",
    )
    (row_detectors / "__init__.py").write_text(
        "__all__ = ['header']\n",
        encoding="utf-8",
    )
    (row_detectors / "header.py").write_text(
        dedent(
            """\
            def ping() -> str:
                \"\"\"Return a sentinel used by the smoke test.\"\"\"
                return "hello-from-snapshot"
            """
        ),
        encoding="utf-8",
    )

    manifest = {
        "name": f"{paths.config_id}-demo",
        "version": "0.0.0",
        "scriptApiVersion": 1,
        "description": "Sample ADE config generated by ade_smoke.py",
        "entrypoints": {
            "rowDetectors": {
                "header": "ade_config.row_detectors.header:ping"
            }
        },
    }
    (cfg_dir / "manifest.json").write_text(
        json.dumps(manifest, indent=2),
        encoding="utf-8",
    )
    (cfg_dir / ".env").write_text(
        "CONFIG_SAMPLE_FLAG=enabled\n",
        encoding="utf-8",
    )
    req_lines = [
        "# Requirements for smoke test parity with docs",
        *dependencies,
        "",
    ]
    (cfg_dir / "requirements.txt").write_text("\n".join(req_lines), encoding="utf-8")


def create_venv(paths: ADEPaths) -> Path:
    python_bin = paths.venv_python()
    if python_bin.exists():
        _log("prep", f"venv already exists at {paths.venv_dir}")
        return python_bin

    _log("prep", f"creating venv at {paths.venv_dir}")
    subprocess.run(
        [sys.executable, "-m", "venv", str(paths.venv_dir)],
        check=True,
    )
    return python_bin


def install_requirements(paths: ADEPaths, python_bin: Path) -> str:
    req_path = paths.config_dir / "requirements.txt"
    paths.runtime_dir.mkdir(parents=True, exist_ok=True)
    paths.pip_cache_dir.mkdir(parents=True, exist_ok=True)

    if not req_path.exists() or not req_path.read_text(encoding="utf-8").strip():
        msg = "no requirements installed\n"
        _log("prep", "no requirements to install; writing placeholder install.log")
        paths.install_log_path.write_text(msg, encoding="utf-8")
        return msg

    _log("prep", f"installing requirements from {req_path}")
    env = os.environ.copy()
    env.setdefault("PIP_CACHE_DIR", str(paths.pip_cache_dir))
    cmd = [
        str(python_bin),
        "-m",
        "pip",
        "install",
        "--disable-pip-version-check",
        "-r",
        str(req_path),
    ]
    try:
        result = subprocess.run(
            cmd,
            check=True,
            env=env,
            capture_output=True,
            text=True,
        )
    except subprocess.CalledProcessError as exc:
        output = (exc.stdout or "") + (exc.stderr or "")
        paths.install_log_path.write_text(output, encoding="utf-8")
        raise
    else:
        output = (result.stdout or "") + (result.stderr or "")
        paths.install_log_path.write_text(output, encoding="utf-8")
        return output


def install_config_site_packages(paths: ADEPaths, python_bin: Path) -> tuple[list[Path], Path]:
    source_root = paths.config_dir / "site-packages"
    if not source_root.exists():
        raise FileNotFoundError(f"config package is missing site-packages/ at {source_root}")

    site_packages_dir = _get_site_packages(python_bin)
    _log("prep", f"installing config code into {site_packages_dir}")

    installed_roots: list[Path] = []
    for item in sorted(source_root.iterdir(), key=lambda p: p.name):
        dest = site_packages_dir / item.name
        tmp = dest.with_name(f"{dest.name}.ade_tmp")
        if dest.exists():
            if dest.is_dir():
                shutil.rmtree(dest, onerror=_handle_remove_readonly)
            else:
                dest.unlink()
        if tmp.exists():
            shutil.rmtree(tmp, onerror=_handle_remove_readonly)

        if item.is_dir():
            shutil.copytree(item, tmp, copy_function=shutil.copy2)
            _set_read_only_tree(tmp)
            os.replace(tmp, dest)
        else:
            shutil.copy2(item, dest)
            try:
                dest.chmod(READ_ONLY_FILE_MODE)
            except PermissionError:
                pass
        installed_roots.append(dest)

    return installed_roots, site_packages_dir


def _handle_remove_readonly(func, path, _exc) -> None:
    Path(path).chmod(0o755)
    func(path)


def _set_read_only_tree(root: Path) -> None:
    for dirpath, dirnames, filenames in os.walk(root):
        for dname in dirnames:
            try:
                Path(dirpath, dname).chmod(READ_ONLY_DIR_MODE)
            except PermissionError:
                pass
        for fname in filenames:
            if any(fname.endswith(suffix) for suffix in IGNORED_SUFFIXES):
                continue
            try:
                Path(dirpath, fname).chmod(READ_ONLY_FILE_MODE)
            except PermissionError:
                pass


def copy_config_metadata(paths: ADEPaths) -> None:
    runtime_dir = paths.runtime_dir
    runtime_dir.mkdir(parents=True, exist_ok=True)

    manifest_src = paths.config_dir / "manifest.json"
    if manifest_src.exists():
        shutil.copy2(manifest_src, paths.manifest_runtime_path)

    env_src = paths.config_dir / ".env"
    if env_src.exists():
        shutil.copy2(env_src, paths.config_env_runtime_path)
    elif paths.config_env_runtime_path.exists():
        paths.config_env_runtime_path.unlink()


def _get_site_packages(venv_python: Path) -> Path:
    code = "import sysconfig, json; print(json.dumps(sysconfig.get_paths()))"
    result = subprocess.run(
        [str(venv_python), "-c", code],
        check=True,
        capture_output=True,
        text=True,
    )
    paths = json.loads(result.stdout)
    return Path(paths["purelib"])


def freeze_metadata(paths: ADEPaths, python_bin: Path, config_roots: list[Path]) -> dict:
    _log("meta", "capturing packages.txt and build.json")
    freeze_output = subprocess.run(
        [str(python_bin), "-m", "pip", "freeze"],
        check=True,
        capture_output=True,
        text=True,
    ).stdout
    paths.packages_txt_path.write_text(freeze_output or "", encoding="utf-8")

    content_hash = _combined_tree_hash(config_roots)
    deps_hash = hashlib.sha256(paths.packages_txt_path.read_bytes()).hexdigest()
    python_version = subprocess.run(
        [str(python_bin), "-c", "import platform; print(platform.python_version())"],
        check=True,
        capture_output=True,
        text=True,
    ).stdout.strip()

    metadata = {
        "config_id": paths.config_id,
        "content_hash": content_hash,
        "deps_hash": deps_hash,
        "python_version": python_version,
        "ade_engine_version": "v1-smoke",
        "prepared_at": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
    }
    paths.build_json_path.write_text(json.dumps(metadata, indent=2), encoding="utf-8")
    return metadata


def _stable_tree_hash(root: Path) -> str:
    if not root.exists():
        return "0" * 64

    digest = hashlib.sha256()
    for dirpath, dirnames, filenames in os.walk(root):
        dirnames[:] = sorted(
            d for d in dirnames if d not in IGNORED_NAMES
        )
        rel_dir = Path(dirpath).relative_to(root).as_posix()
        digest.update(rel_dir.encode("utf-8") + b"\0")
        for name in sorted(filenames):
            if name in IGNORED_NAMES:
                continue
            if any(name.endswith(suffix) for suffix in IGNORED_SUFFIXES):
                continue
            file_path = Path(dirpath) / name
            rel_path = file_path.relative_to(root).as_posix().encode("utf-8")
            digest.update(rel_path + b"\0")
            with open(file_path, "rb") as handle:
                for chunk in iter(lambda: handle.read(1 << 20), b""):
                    digest.update(chunk)
    return digest.hexdigest()


def _combined_tree_hash(roots: list[Path]) -> str:
    if not roots:
        return "0" * 64
    digest = hashlib.sha256()
    for root in sorted(roots, key=lambda p: p.as_posix()):
        digest.update(root.as_posix().encode("utf-8") + b"\0")
        digest.update(_stable_tree_hash(root).encode("ascii"))
    return digest.hexdigest()


def smoke_import(paths: ADEPaths, python_bin: Path) -> None:
    _log("test", "verifying imports resolve from installed config (-I -B)")
    env = os.environ.copy()
    env["ADE_RUNTIME_DIR"] = str(paths.runtime_dir)
    env.update(_parse_config_env(paths.config_env_runtime_path))

    code = dedent(
        """\
        import json
        import os
        import pathlib

        runtime_dir = pathlib.Path(os.environ["ADE_RUNTIME_DIR"])
        manifest = json.loads((runtime_dir / "manifest.json").read_text(encoding="utf-8"))
        from ade_config.row_detectors import header

        print("RUNTIME_DIR", runtime_dir)
        print("IMPORT_OK", header.ping())
        print("HEADER_PATH", getattr(header, "__file__", "<unknown>"))
        print("MANIFEST_NAME", manifest.get("name"))
        print("CONFIG_SAMPLE_FLAG", os.getenv("CONFIG_SAMPLE_FLAG"))
        """
    )
    result = subprocess.run(
        [str(python_bin), "-I", "-B", "-c", code],
        check=True,
        capture_output=True,
        text=True,
        env=env,
    )
    print(result.stdout, end="")
    if "IMPORT_OK hello-from-snapshot" not in result.stdout:
        raise AssertionError("failed to import installed config code")


def _parse_config_env(env_path: Path) -> dict:
    if not env_path.exists():
        return {}
    env_vars: dict[str, str] = {}
    for raw_line in env_path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        key, value = line.split("=", 1)
        env_vars[key.strip()] = value.strip()
    return env_vars


def parse_args(argv: list[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="ADE smoke test (stdlib-only)")
    parser.add_argument(
        "--ade-data-dir",
        default="./data",
        help="ADE_DATA_DIR root (default: ./data)",
    )
    parser.add_argument(
        "--config-id",
        default="demo-openpyxl-a,demo-openpyxl-b",
        help="Comma-separated config identifiers to exercise (default: demo-openpyxl-a,demo-openpyxl-b)",
    )
    return parser.parse_args(argv)


def main(argv: list[str] | None = None) -> None:
    args = parse_args(argv)
    data_root = Path(args.ade_data_dir).expanduser().resolve()
    config_ids = [cid.strip() for cid in args.config_id.split(",") if cid.strip()]
    if not config_ids:
        raise ValueError("at least one --config-id is required")

    results: list[dict[str, object]] = []

    for idx, config_id in enumerate(config_ids):
        paths = ADEPaths(data_root=data_root, config_id=config_id)

        _log("init", f"ADE_DATA_DIR = {paths.data_root}")
        _log("init", f"config_id    = {paths.config_id}")

        ensure_data_roots(paths)
        ensure_sample_config(paths)
        python_bin = create_venv(paths)
        install_log = install_requirements(paths, python_bin)

        if "openpyxl" not in install_log:
            raise AssertionError("openpyxl not mentioned in pip install log; check requirements.txt")
        cache_hit = "Using cached openpyxl" in install_log
        if idx > 0 and not cache_hit:
            raise AssertionError("expected pip to use cached openpyxl on subsequent prepares")

        copy_config_metadata(paths)
        installed_roots, site_packages_dir = install_config_site_packages(paths, python_bin)
        metadata = freeze_metadata(paths, python_bin, installed_roots)
        smoke_import(paths, python_bin)

        _log("done", f"Smoke test passed for {config_id}.")
        installed_labels = ", ".join(p.name for p in installed_roots) or "<none>"
        print(
            dedent(
                f"""\
                Result for {config_id}:
                  - Runtime metadata:  {paths.runtime_dir}
                  - Config code in:    {site_packages_dir} (installed: {installed_labels})
                  - pip freeze output: {paths.packages_txt_path}
                  - build metadata:    {paths.build_json_path}
                  - manifest copy:     {paths.manifest_runtime_path}
                  - metadata summary:  {json.dumps(metadata, indent=2)}
                """
            )
        )

        results.append(
            {
                "config_id": config_id,
                "venv_python": paths.venv_python(),
                "site_packages": site_packages_dir,
                "cache_hit": cache_hit,
                "install_log": paths.install_log_path,
                "build_json": paths.build_json_path,
                "metadata": metadata,
            }
        )

    print("\nPip cache summary:")
    for result in results:
        hit = "yes" if result["cache_hit"] else "no"
        print(
            f"  - {result['config_id']}: cache hit = {hit} | venv = {result['venv_python']}"
        )



if __name__ == "__main__":
    try:
        main()
    except subprocess.CalledProcessError as exc:
        output = ""
        if getattr(exc, "stdout", None):
            output += exc.stdout
        if getattr(exc, "stderr", None):
            output += exc.stderr
        print(
            f"\n[ERROR] Command failed: {exc.cmd}\n"
            f"exit={exc.returncode}\n"
            f"output:\n{output}",
            file=sys.stderr,
        )
        sys.exit(1)
    except AssertionError as exc:
        print(f"\n[ERROR] {exc}", file=sys.stderr)
        sys.exit(2)
