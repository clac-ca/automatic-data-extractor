$ErrorActionPreference = "Stop"

# Dependencies:
# - Azure CLI (az): https://learn.microsoft.com/cli/azure/install-azure-cli
# - PostgreSQL client (psql): https://www.postgresql.org/download/

function Require-Command {
    param([Parameter(Mandatory = $true)][string]$Name)

    if (-not (Get-Command $Name -ErrorAction SilentlyContinue)) {
        throw "Required command not found: $Name"
    }
}

function Require-Value {
    param(
        [Parameter(Mandatory = $true)][string]$Name,
        [Parameter(Mandatory = $true)][string]$Value
    )

    if ([string]::IsNullOrWhiteSpace($Value)) {
        throw "Missing required value: $Name"
    }
}

Require-Command -Name "az"
Require-Command -Name "psql"

# Copy this file to deploy-prod-dev.ps1 and replace all <...> placeholders.
# This script always deploys production + development.

$subscriptionId = "<SUBSCRIPTION_ID>"
$resourceGroupName = "rg-ade-shared-canadacentral-001"
$location = "canadacentral"
$deploymentName = "ade-azure-production-and-development-$((Get-Date).ToString('yyyyMMdd-HHmmss'))"

$workload = "ade"
$instance = "001"
$virtualNetworkAddressPrefix = "10.80.0.0/16"
$containerAppsSubnetAddressPrefix = "10.80.0.0/23"

$postgresqlVersion = "18"
$postgresqlSkuTier = "Burstable"
$postgresqlSkuName = "Standard_B1ms"
$postgresqlStorageSizeGb = "32"
$postgresqlProductionDatabaseName = "ade"
$postgresqlDevelopmentDatabaseName = "ade_dev"
$postgresqlAllowPublicAccessFromAzureServices = "true"
$publicIpv4Allowlist = '["<ADMIN_PUBLIC_IPV4>"]'

$storageAccountSkuName = "Standard_LRS"

$accessControlGroupNamePrefix = "ade"

$productionContainerAppImage = "ghcr.io/clac-ca/automatic-data-extractor:<PRODUCTION_TAG>"
$productionContainerAppPublicWebUrl = ""
$productionContainerAppSecretKey = "<ADE_SECRET_KEY>"
$productionContainerAppEnvironmentOverrides = '{"ADE_LOG_LEVEL":"INFO","ADE_LOG_FORMAT":"json","ADE_AUTH_DISABLED":"false"}'
$productionContainerAppMinimumReplicas = "1"
$productionContainerAppMaximumReplicas = "1"

$developmentContainerAppImage = "ghcr.io/clac-ca/automatic-data-extractor:<DEVELOPMENT_TAG>"
$developmentContainerAppPublicWebUrl = ""
$developmentContainerAppSecretKey = ""
$developmentContainerAppEnvironmentOverrides = '{"ADE_LOG_LEVEL":"DEBUG","ADE_LOG_FORMAT":"json","ADE_AUTH_DISABLED":"false"}'
$developmentContainerAppMinimumReplicas = "0"
$developmentContainerAppMaximumReplicas = "1"

$postgresqlBootstrapEntraAdminLogin = "<POSTGRESQL_BOOTSTRAP_ENTRA_ADMIN_LOGIN>"
$postgresqlBootstrapEntraAdminObjectId = "<POSTGRESQL_BOOTSTRAP_ENTRA_ADMIN_OBJECT_ID>"
$postgresqlBootstrapEntraAdminType = "User"

Require-Value -Name "POSTGRESQL_BOOTSTRAP_ENTRA_ADMIN_LOGIN" -Value $postgresqlBootstrapEntraAdminLogin
Require-Value -Name "POSTGRESQL_BOOTSTRAP_ENTRA_ADMIN_OBJECT_ID" -Value $postgresqlBootstrapEntraAdminObjectId
Require-Value -Name "POSTGRESQL_BOOTSTRAP_ENTRA_ADMIN_TYPE" -Value $postgresqlBootstrapEntraAdminType

$resourceGroupOwnersGroupName = "$accessControlGroupNamePrefix-rg-owners"
$resourceGroupContributorsGroupName = "$accessControlGroupNamePrefix-rg-contributors"
$resourceGroupReadersGroupName = "$accessControlGroupNamePrefix-rg-readers"
$containerAppsAdminsGroupName = "$accessControlGroupNamePrefix-ca-admins"
$containerAppsOperatorsGroupName = "$accessControlGroupNamePrefix-ca-operators"
$containerAppsReadersGroupName = "$accessControlGroupNamePrefix-ca-readers"
$databaseAdminsGroupName = "$accessControlGroupNamePrefix-db-admins"
$databaseReadWriteGroupName = "$accessControlGroupNamePrefix-db-readwrite"
$databaseReadOnlyGroupName = "$accessControlGroupNamePrefix-db-readonly"
$storageAdminsGroupName = "$accessControlGroupNamePrefix-st-admins"
$storageReadWriteGroupName = "$accessControlGroupNamePrefix-st-readwrite"
$storageReadOnlyGroupName = "$accessControlGroupNamePrefix-st-readonly"

function Get-GroupMailNickname {
    param([Parameter(Mandatory = $true)][string]$GroupName)

    $normalized = ($GroupName.ToLower() -replace '[^a-z0-9]', '')
    if ([string]::IsNullOrWhiteSpace($normalized)) {
        $normalized = 'adegroup'
    }
    if ($normalized.Length -gt 48) {
        $normalized = $normalized.Substring(0, 48)
    }

    $sha = [System.Security.Cryptography.SHA256]::Create()
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($GroupName)
    $hashBytes = $sha.ComputeHash($bytes)
    $hashHex = ([System.BitConverter]::ToString($hashBytes)).Replace('-', '').ToLower().Substring(0, 8)
    $nickname = "$normalized$hashHex"
    if ($nickname.Length -gt 64) {
        $nickname = $nickname.Substring(0, 64)
    }
    return $nickname
}

function Get-OrCreateGroupObjectId {
    param([Parameter(Mandatory = $true)][string]$GroupName)

    $objectId = az ad group list --filter "displayName eq '$GroupName'" --query '[0].id' -o tsv 2>$null
    if (-not [string]::IsNullOrWhiteSpace($objectId)) {
        return $objectId
    }

    az ad group create --display-name $GroupName --mail-nickname (Get-GroupMailNickname -GroupName $GroupName) --query id -o tsv | Out-Null

    $objectId = az ad group list --filter "displayName eq '$GroupName'" --query '[0].id' -o tsv 2>$null
    if ([string]::IsNullOrWhiteSpace($objectId)) {
        throw "Failed to resolve object ID for group '$GroupName'."
    }

    return $objectId
}

function Get-DeploymentOutputValue {
    param([Parameter(Mandatory = $true)][string]$QueryPath)

    $value = az deployment group show `
      --subscription $subscriptionId `
      --resource-group $resourceGroupName `
      --name $deploymentName `
      --query "properties.outputs.$QueryPath" `
      -o tsv

    if ($value -eq "null") {
      return ""
    }

    return $value
}

function Wait-PostgresqlReady {
    param([Parameter(Mandatory = $true)][string]$ServerName)

    $maxAttempts = 30
    $waitSeconds = 20

    for ($attempt = 1; $attempt -le $maxAttempts; $attempt++) {
        $state = az postgres flexible-server show --subscription $subscriptionId --resource-group $resourceGroupName --name $ServerName --query state -o tsv 2>$null
        if ($state -eq "Ready") {
            return
        }

        if ($attempt -eq $maxAttempts) {
            throw "PostgreSQL server '$ServerName' did not reach Ready state (last state: $state)."
        }

        Write-Host "Waiting for PostgreSQL server '$ServerName' to become Ready (attempt $attempt/$maxAttempts, current: $state)..."
        Start-Sleep -Seconds $waitSeconds
    }
}

function Set-PostgresqlEntraAdminWithRetry {
    param(
        [Parameter(Mandatory = $true)][string]$ServerName,
        [Parameter(Mandatory = $true)][string]$DisplayName,
        [Parameter(Mandatory = $true)][string]$ObjectId,
        [Parameter(Mandatory = $true)][string]$PrincipalType
    )

    $maxAttempts = 20
    $waitSeconds = 15

    for ($attempt = 1; $attempt -le $maxAttempts; $attempt++) {
        az postgres flexible-server microsoft-entra-admin create `
          --subscription $subscriptionId `
          --resource-group $resourceGroupName `
          --server-name $ServerName `
          --display-name $DisplayName `
          --object-id $ObjectId `
          --type $PrincipalType `
          --only-show-errors | Out-Null

        if ($LASTEXITCODE -eq 0) {
            return
        }

        if ($attempt -eq $maxAttempts) {
            throw "Failed to set PostgreSQL Entra admin '$DisplayName' after $maxAttempts attempts."
        }

        Write-Host "Failed to set PostgreSQL Entra admin '$DisplayName' (attempt $attempt/$maxAttempts); retrying in $waitSeconds seconds..."
        Start-Sleep -Seconds $waitSeconds
    }
}

function Get-PostgresqlToken {
    return az account get-access-token --resource-type oss-rdbms --query accessToken -o tsv
}

function Invoke-SqlWithRetry {
    param(
        [Parameter(Mandatory = $true)][string]$ServerFqdn,
        [Parameter(Mandatory = $true)][string]$Login,
        [Parameter(Mandatory = $true)][string]$Database,
        [Parameter(Mandatory = $true)][string]$Sql
    )

    $maxAttempts = 20
    $waitSeconds = 15

    for ($attempt = 1; $attempt -le $maxAttempts; $attempt++) {
        $env:PGPASSWORD = Get-PostgresqlToken
        $env:PGCONNECT_TIMEOUT = "15"

        $result = & psql "host=$ServerFqdn port=5432 dbname=$Database user=$Login sslmode=require" --set ON_ERROR_STOP=on --quiet --command $Sql 2>&1
        if ($LASTEXITCODE -eq 0) {
            return
        }

        if ($attempt -eq $maxAttempts) {
            throw "SQL execution failed after $maxAttempts attempts on database '$Database'. Last error: $result"
        }

        Write-Host "SQL execution attempt $attempt/$maxAttempts failed for database '$Database'; retrying in $waitSeconds seconds..."
        Start-Sleep -Seconds $waitSeconds
    }
}

function Create-PrincipalRoleIfMissing {
    param(
        [Parameter(Mandatory = $true)][string]$ServerFqdn,
        [Parameter(Mandatory = $true)][string]$Login,
        [Parameter(Mandatory = $true)][string]$RoleName,
        [Parameter(Mandatory = $true)][string]$ObjectId,
        [Parameter(Mandatory = $true)][string]$PrincipalType
    )

    $sql = "DO `$`$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_catalog.pg_roles WHERE rolname = '$RoleName') THEN PERFORM pg_catalog.pgaadauth_create_principal_with_oid('$RoleName', '$ObjectId', '$PrincipalType', false, false); END IF; END `$`$;"
    Invoke-SqlWithRetry -ServerFqdn $ServerFqdn -Login $Login -Database "postgres" -Sql $sql
}

function Apply-AppRoleGrants {
    param(
        [Parameter(Mandatory = $true)][string]$ServerFqdn,
        [Parameter(Mandatory = $true)][string]$Login,
        [Parameter(Mandatory = $true)][string]$DatabaseName,
        [Parameter(Mandatory = $true)][string]$RoleName
    )

    Invoke-SqlWithRetry -ServerFqdn $ServerFqdn -Login $Login -Database "postgres" -Sql "GRANT CONNECT, CREATE, TEMP ON DATABASE `"$DatabaseName`" TO `"$RoleName`";"
    Invoke-SqlWithRetry -ServerFqdn $ServerFqdn -Login $Login -Database $DatabaseName -Sql "GRANT USAGE, CREATE ON SCHEMA public TO `"$RoleName`";"
    Invoke-SqlWithRetry -ServerFqdn $ServerFqdn -Login $Login -Database $DatabaseName -Sql "GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO `"$RoleName`";"
    Invoke-SqlWithRetry -ServerFqdn $ServerFqdn -Login $Login -Database $DatabaseName -Sql "GRANT USAGE, SELECT, UPDATE ON ALL SEQUENCES IN SCHEMA public TO `"$RoleName`";"
}

function Apply-DatabaseGroupGrants {
    param(
        [Parameter(Mandatory = $true)][string]$ServerFqdn,
        [Parameter(Mandatory = $true)][string]$Login,
        [Parameter(Mandatory = $true)][string]$DatabaseName,
        [Parameter(Mandatory = $true)][string]$ReadWriteRole,
        [Parameter(Mandatory = $true)][string]$ReadOnlyRole
    )

    Invoke-SqlWithRetry -ServerFqdn $ServerFqdn -Login $Login -Database "postgres" -Sql "GRANT CONNECT, TEMP ON DATABASE `"$DatabaseName`" TO `"$ReadWriteRole`";"
    Invoke-SqlWithRetry -ServerFqdn $ServerFqdn -Login $Login -Database "postgres" -Sql "GRANT CONNECT ON DATABASE `"$DatabaseName`" TO `"$ReadOnlyRole`";"

    Invoke-SqlWithRetry -ServerFqdn $ServerFqdn -Login $Login -Database $DatabaseName -Sql "GRANT USAGE, CREATE ON SCHEMA public TO `"$ReadWriteRole`";"
    Invoke-SqlWithRetry -ServerFqdn $ServerFqdn -Login $Login -Database $DatabaseName -Sql "GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO `"$ReadWriteRole`";"
    Invoke-SqlWithRetry -ServerFqdn $ServerFqdn -Login $Login -Database $DatabaseName -Sql "GRANT USAGE, SELECT, UPDATE ON ALL SEQUENCES IN SCHEMA public TO `"$ReadWriteRole`";"

    Invoke-SqlWithRetry -ServerFqdn $ServerFqdn -Login $Login -Database $DatabaseName -Sql "GRANT USAGE ON SCHEMA public TO `"$ReadOnlyRole`";"
    Invoke-SqlWithRetry -ServerFqdn $ServerFqdn -Login $Login -Database $DatabaseName -Sql "GRANT SELECT ON ALL TABLES IN SCHEMA public TO `"$ReadOnlyRole`";"
    Invoke-SqlWithRetry -ServerFqdn $ServerFqdn -Login $Login -Database $DatabaseName -Sql "GRANT SELECT ON ALL SEQUENCES IN SCHEMA public TO `"$ReadOnlyRole`";"
}

az login
az account set --subscription $subscriptionId
az group create --subscription $subscriptionId --name $resourceGroupName --location $location | Out-Null

$resourceGroupOwnersGroupObjectId = Get-OrCreateGroupObjectId -GroupName $resourceGroupOwnersGroupName
$resourceGroupContributorsGroupObjectId = Get-OrCreateGroupObjectId -GroupName $resourceGroupContributorsGroupName
$resourceGroupReadersGroupObjectId = Get-OrCreateGroupObjectId -GroupName $resourceGroupReadersGroupName
$containerAppsAdminsGroupObjectId = Get-OrCreateGroupObjectId -GroupName $containerAppsAdminsGroupName
$containerAppsOperatorsGroupObjectId = Get-OrCreateGroupObjectId -GroupName $containerAppsOperatorsGroupName
$containerAppsReadersGroupObjectId = Get-OrCreateGroupObjectId -GroupName $containerAppsReadersGroupName
$databaseAdminsGroupObjectId = Get-OrCreateGroupObjectId -GroupName $databaseAdminsGroupName
$databaseReadWriteGroupObjectId = Get-OrCreateGroupObjectId -GroupName $databaseReadWriteGroupName
$databaseReadOnlyGroupObjectId = Get-OrCreateGroupObjectId -GroupName $databaseReadOnlyGroupName
$storageAdminsGroupObjectId = Get-OrCreateGroupObjectId -GroupName $storageAdminsGroupName
$storageReadWriteGroupObjectId = Get-OrCreateGroupObjectId -GroupName $storageReadWriteGroupName
$storageReadOnlyGroupObjectId = Get-OrCreateGroupObjectId -GroupName $storageReadOnlyGroupName

az deployment group create `
  --subscription $subscriptionId `
  --resource-group $resourceGroupName `
  --name $deploymentName `
  --template-file infra/azure/main.bicep `
  --parameters `
    location="$location" `
    workload="$workload" `
    instance="$instance" `
    deployDevelopmentEnvironment=true `
    virtualNetworkAddressPrefix="$virtualNetworkAddressPrefix" `
    containerAppsSubnetAddressPrefix="$containerAppsSubnetAddressPrefix" `
    postgresqlVersion="$postgresqlVersion" `
    postgresqlSkuTier="$postgresqlSkuTier" `
    postgresqlSkuName="$postgresqlSkuName" `
    postgresqlStorageSizeGb="$postgresqlStorageSizeGb" `
    postgresqlProductionDatabaseName="$postgresqlProductionDatabaseName" `
    postgresqlDevelopmentDatabaseName="$postgresqlDevelopmentDatabaseName" `
    postgresqlAllowPublicAccessFromAzureServices="$postgresqlAllowPublicAccessFromAzureServices" `
    publicIpv4Allowlist="$publicIpv4Allowlist" `
    storageAccountSkuName="$storageAccountSkuName" `
    resourceGroupOwnersEntraGroupObjectId="$resourceGroupOwnersGroupObjectId" `
    resourceGroupContributorsEntraGroupObjectId="$resourceGroupContributorsGroupObjectId" `
    resourceGroupReadersEntraGroupObjectId="$resourceGroupReadersGroupObjectId" `
    containerAppsAdminsEntraGroupObjectId="$containerAppsAdminsGroupObjectId" `
    containerAppsOperatorsEntraGroupObjectId="$containerAppsOperatorsGroupObjectId" `
    containerAppsReadersEntraGroupObjectId="$containerAppsReadersGroupObjectId" `
    databaseAdminsEntraGroupObjectId="$databaseAdminsGroupObjectId" `
    databaseReadWriteEntraGroupObjectId="$databaseReadWriteGroupObjectId" `
    databaseReadOnlyEntraGroupObjectId="$databaseReadOnlyGroupObjectId" `
    storageAdminsEntraGroupObjectId="$storageAdminsGroupObjectId" `
    storageReadWriteEntraGroupObjectId="$storageReadWriteGroupObjectId" `
    storageReadOnlyEntraGroupObjectId="$storageReadOnlyGroupObjectId" `
    productionContainerAppImage="$productionContainerAppImage" `
    productionContainerAppPublicWebUrl="$productionContainerAppPublicWebUrl" `
    productionContainerAppSecretKey="$productionContainerAppSecretKey" `
    productionContainerAppEnvironmentOverrides="$productionContainerAppEnvironmentOverrides" `
    productionContainerAppMinimumReplicas="$productionContainerAppMinimumReplicas" `
    productionContainerAppMaximumReplicas="$productionContainerAppMaximumReplicas" `
    developmentContainerAppImage="$developmentContainerAppImage" `
    developmentContainerAppPublicWebUrl="$developmentContainerAppPublicWebUrl" `
    developmentContainerAppSecretKey="$developmentContainerAppSecretKey" `
    developmentContainerAppEnvironmentOverrides="$developmentContainerAppEnvironmentOverrides" `
    developmentContainerAppMinimumReplicas="$developmentContainerAppMinimumReplicas" `
    developmentContainerAppMaximumReplicas="$developmentContainerAppMaximumReplicas"

$postgresqlServerName = Get-DeploymentOutputValue -QueryPath "postgresqlServerName.value"
$postgresqlServerFqdn = Get-DeploymentOutputValue -QueryPath "postgresqlFullyQualifiedDomainName.value"
$productionContainerAppName = Get-DeploymentOutputValue -QueryPath "productionContainerAppName.value"
$productionContainerAppObjectId = Get-DeploymentOutputValue -QueryPath "productionContainerAppPrincipalId.value"
$productionDatabaseName = Get-DeploymentOutputValue -QueryPath "postgresqlProductionDatabaseName.value"
$developmentContainerAppName = Get-DeploymentOutputValue -QueryPath "developmentContainerAppName.value"
$developmentContainerAppObjectId = Get-DeploymentOutputValue -QueryPath "developmentContainerAppPrincipalId.value"
$developmentDatabaseName = Get-DeploymentOutputValue -QueryPath "postgresqlDevelopmentDatabaseName.value"

if ([string]::IsNullOrWhiteSpace($postgresqlServerName) -or [string]::IsNullOrWhiteSpace($postgresqlServerFqdn)) {
    throw "Missing PostgreSQL deployment outputs required for bootstrap."
}

Wait-PostgresqlReady -ServerName $postgresqlServerName

Set-PostgresqlEntraAdminWithRetry `
  -ServerName $postgresqlServerName `
  -DisplayName $postgresqlBootstrapEntraAdminLogin `
  -ObjectId $postgresqlBootstrapEntraAdminObjectId `
  -PrincipalType $postgresqlBootstrapEntraAdminType

Create-PrincipalRoleIfMissing -ServerFqdn $postgresqlServerFqdn -Login $postgresqlBootstrapEntraAdminLogin -RoleName $productionContainerAppName -ObjectId $productionContainerAppObjectId -PrincipalType "service"
Apply-AppRoleGrants -ServerFqdn $postgresqlServerFqdn -Login $postgresqlBootstrapEntraAdminLogin -DatabaseName $productionDatabaseName -RoleName $productionContainerAppName

Create-PrincipalRoleIfMissing -ServerFqdn $postgresqlServerFqdn -Login $postgresqlBootstrapEntraAdminLogin -RoleName $developmentContainerAppName -ObjectId $developmentContainerAppObjectId -PrincipalType "service"
Apply-AppRoleGrants -ServerFqdn $postgresqlServerFqdn -Login $postgresqlBootstrapEntraAdminLogin -DatabaseName $developmentDatabaseName -RoleName $developmentContainerAppName

Create-PrincipalRoleIfMissing -ServerFqdn $postgresqlServerFqdn -Login $postgresqlBootstrapEntraAdminLogin -RoleName $databaseReadWriteGroupName -ObjectId $databaseReadWriteGroupObjectId -PrincipalType "group"
Create-PrincipalRoleIfMissing -ServerFqdn $postgresqlServerFqdn -Login $postgresqlBootstrapEntraAdminLogin -RoleName $databaseReadOnlyGroupName -ObjectId $databaseReadOnlyGroupObjectId -PrincipalType "group"

Apply-DatabaseGroupGrants -ServerFqdn $postgresqlServerFqdn -Login $postgresqlBootstrapEntraAdminLogin -DatabaseName $productionDatabaseName -ReadWriteRole $databaseReadWriteGroupName -ReadOnlyRole $databaseReadOnlyGroupName
Apply-DatabaseGroupGrants -ServerFqdn $postgresqlServerFqdn -Login $postgresqlBootstrapEntraAdminLogin -DatabaseName $developmentDatabaseName -ReadWriteRole $databaseReadWriteGroupName -ReadOnlyRole $databaseReadOnlyGroupName

Set-PostgresqlEntraAdminWithRetry `
  -ServerName $postgresqlServerName `
  -DisplayName $databaseAdminsGroupName `
  -ObjectId $databaseAdminsGroupObjectId `
  -PrincipalType Group

Write-Host "Production + development deployment complete: $deploymentName"
