# API Design - Runs and Builds (Implemented)

This reflects the **current ade-api surface** in `apps/ade-api/src/ade_api/features/runs/router.py` and `.../builds/router.py`.

---

## 1. Run endpoints

### 1.1 Create a run

```
POST /configurations/{configuration_id}/runs
Content-Type: application/json
Accept: application/json | text/event-stream
Body: RunCreateRequest { stream: boolean, options: RunCreateOptions }
```

- `stream=false` (default):
  - Returns `RunResource` (full run object with status, ids, links).
  - Background execution is queued via `BackgroundTasks` calling `_execute_run_background`.
- `stream=true`:
  - Executes inline and streams **SSE** frames (`event: ade.event`) produced by `RunsService.stream_run`.
  - Formatter: `_sse_event_bytes` sets `id: <sequence>` when present.

### 1.2 Run metadata and summary

- `GET /runs/{run_id}` → `RunResource`
- `GET /runs/{run_id}/summary` → `RunSummaryV1`

### 1.3 Run events (replay + streaming)

```
GET /runs/{run_id}/events?stream={false|true}&after_sequence={n}&limit={1-1000}&format={json|ndjson}
```

- `stream=true`:
  - Replays persisted events from `RunEventLogReader` (NDJSON under `.../runs/{run_id}/logs/events.ndjson`) honoring `after_sequence`/`limit`, then fans out live events from `RunEventDispatcher.subscribe`.
  - SSE frames use `event: ade.event` and `id: <sequence>`.
- `stream=false`:
  - `format=json` (default) → `RunEventsPage { items, next_after_sequence }`.
  - `format=ndjson` → streaming NDJSON body (`Content-Type: application/x-ndjson`).

### 1.4 Run logs and outputs

- `GET /runs/{run_id}/logs` → paginated DB-backed `RunLogsResponse`.
- `GET /runs/{run_id}/logfile` → raw NDJSON file (`logs/events.ndjson`).
- `GET /runs/{run_id}/outputs` → `RunOutputListing`; `GET /runs/{run_id}/outputs/{path}` → file download.
- `GET /runs/{run_id}/diagnostics` → artifact/diagnostics JSON.

---

## 2. Build endpoint (secondary)

```
POST /workspaces/{workspace_id}/configurations/{configuration_id}/builds
Content-Type: application/json
Accept: application/json | text/event-stream
Body: BuildCreateRequest { stream: boolean, options: BuildCreateOptions }
```

- `stream=false`: returns `BuildResource`; background build executes via `_execute_build_background`.
- `stream=true`: streams **SSE** events from `BuildsService.stream_build` (`build.*` + `console.line` scope=`build`). These envelopes do **not** receive `event_id`/`sequence` because they bypass `RunEventDispatcher`.

---

## 3. Streaming format (SSE)

- Event name: `ade.event`
- `id` header: `sequence` when available (run streams only)
- Data: serialized `AdeEvent` JSON (payload may contain nested objects)
- Frontend connects via `EventSource` and listens to `ade.event` (see `apps/ade-web/src/shared/runs/api.ts::streamRunEvents`).

---

## 4. Request/response examples (real code paths)

- Create + stream run: `POST /configurations/{config_id}/runs?stream=true` → SSE of `run.queued`, `build.*` (if streaming build), `console.line`, engine events, `run.completed`.
- Attach to existing run: `GET /runs/{run_id}/events?stream=true&after_sequence=0` → SSE replay + live.
- Fetch run summary: `GET /runs/{run_id}/summary` → `RunSummaryV1`.
- Stream build only: `POST /workspaces/{ws}/configurations/{cfg}/builds?stream=true` → SSE of `build.*` + `console.line` (build scope).

---

## 5. Ownership

- Run IDs/build IDs are generated by ade-api (`run_<ulid>`, `build_<uuid>`).
- `RunEventDispatcher` assigns `event_id`/`sequence` for run-scoped events and persists to NDJSON for replay.
- Engine-provided events are re-enveloped by the dispatcher; engine-provided `sequence` is ignored.
