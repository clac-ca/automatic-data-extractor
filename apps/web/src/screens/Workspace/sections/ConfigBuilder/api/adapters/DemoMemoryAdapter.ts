import { createScopedStorage } from "@shared/storage";

import type { ConfigFsAdapter } from "./ConfigFsAdapter";
import type {
  AdapterWriteOptions,
  FileBuffer,
  FileMime,
  FileNode,
  Problem,
  RunResult,
  RunLogLine,
  ValidationResult,
} from "./types";
import { detectMimeFromPath } from "./types";

interface DemoMemoryAdapterOptions {
  readonly workspaceId: string;
  readonly configId: string;
}

interface StoredFileEntry {
  readonly path: string;
  readonly content: string;
  readonly mime: FileMime;
  readonly etag: string;
}

interface StoredDataset {
  readonly files: Record<string, StoredFileEntry>;
}

interface MutableTreeNode {
  path: string;
  name: string;
  kind: "file" | "folder";
  parent: string | null;
  mime?: FileMime;
  size?: number;
  etag?: string;
  children: MutableTreeNode[];
}

const ROOT_PREFIX = "src/ade_config";

const DEFAULT_FILES: StoredFileEntry[] = [
  {
    path: `${ROOT_PREFIX}/manifest.json`,
    mime: "application/json",
    content: JSON.stringify(
      {
        name: "Demo configuration",
        description: "Generated by the in-browser editor",
        columns: [
          {
            key: "email",
            label: "Email",
            path: "column_detectors/email.py",
            required: true,
          },
          {
            key: "header",
            label: "Header",
            path: "row_detectors/header.py",
            required: false,
          },
        ],
        table: {
          transform: {
            path: "hooks/on_job_start.py",
          },
        },
      },
      null,
      2,
    ),
    etag: buildEtag(),
  },
  {
    path: `${ROOT_PREFIX}/column_detectors/email.py`,
    mime: "text/x-python",
    content: [
      "from __future__ import annotations",
      "",
      "def detect(row):",
      "    email = row.get('email')",
      "    if email and '@' in email:",
      "        return {'email': email.lower()}",
      "    return None",
      "",
      "# Remove the line below to clear the demo validation error",
      "# RAISE_ERROR",
    ].join("\n"),
    etag: buildEtag(),
  },
  {
    path: `${ROOT_PREFIX}/row_detectors/header.py`,
    mime: "text/x-python",
    content: [
      "def detect(row):",
      "    header = row.get('header')",
      "    if header and header.strip():",
      "        return {'header': header.strip()}",
      "    return None",
    ].join("\n"),
    etag: buildEtag(),
  },
  {
    path: `${ROOT_PREFIX}/hooks/on_job_start.py`,
    mime: "text/x-python",
    content: [
      "def on_job_start(context):",
      "    context.log('Job starting...')",
      "    return context",
    ].join("\n"),
    etag: buildEtag(),
  },
  {
    path: `${ROOT_PREFIX}/config.env`,
    mime: "text/x-shellscript",
    content: "# Environment variables for the ADE configuration\nLOG_LEVEL=INFO\n",
    etag: buildEtag(),
  },
];

export class DemoMemoryAdapter implements ConfigFsAdapter {
  private readonly storageKey: string;
  private dataset: StoredDataset;

  constructor(options: DemoMemoryAdapterOptions) {
    this.storageKey = `ade.demo.fs.${options.workspaceId}.${options.configId}`;
    const stored = this.readFromStorage();
    if (stored) {
      this.dataset = stored;
    } else {
      this.dataset = {
        files: Object.fromEntries(DEFAULT_FILES.map((entry) => [entry.path, entry])),
      };
      this.persist();
    }
  }

  async listTree(): Promise<FileNode[]> {
    const nodes = new Map<string, MutableTreeNode>();

    const ensureDir = (path: string) => {
      if (nodes.has(path)) {
        return nodes.get(path)!;
      }
      const parent = path.includes("/") ? path.slice(0, path.lastIndexOf("/")) : null;
      const node: MutableTreeNode = {
        path,
        name: path.split("/").pop() ?? path,
        kind: "folder",
        parent,
        children: [],
      };
      nodes.set(path, node);
      if (parent) {
        const parentNode = ensureDir(parent);
        if (!parentNode.children.some((child) => child.path === node.path)) {
          parentNode.children.push(node);
        }
      }
      return node;
    };

    Object.values(this.dataset.files).forEach((entry) => {
      const directorySegments = entry.path.split("/");
      directorySegments.pop();
      let current: string | null = null;
      directorySegments.forEach((segment) => {
        const next = current ? `${current}/${segment}` : segment;
        ensureDir(next);
        current = next;
      });

      const parent = current;
      const node: MutableTreeNode = {
        path: entry.path,
        name: entry.path.split("/").pop() ?? entry.path,
        kind: "file",
        parent: parent ?? null,
        mime: entry.mime,
        size: entry.content.length,
        etag: entry.etag,
        children: [],
      };
      nodes.set(entry.path, node);
      if (parent) {
        const parentNode = ensureDir(parent);
        if (!parentNode.children.some((child) => child.path === node.path)) {
          parentNode.children.push(node);
        }
      }
    });

    const rootNodes: MutableTreeNode[] = [];
    nodes.forEach((node) => {
      if (!node.parent || !nodes.has(node.parent)) {
        rootNodes.push(node);
      }
    });

    const normalize = (node: MutableTreeNode): FileNode => ({
      path: node.path,
      name: node.name,
      kind: node.kind,
      parent: node.parent,
      mime: node.mime,
      size: node.size,
      etag: node.etag,
      children: node.children
        .slice()
        .sort((a, b) => {
          if (a.kind !== b.kind) {
            return a.kind === "folder" ? -1 : 1;
          }
          return a.name.localeCompare(b.name);
        })
        .map(normalize),
    });

    const configRoot = nodes.get(ROOT_PREFIX);
    if (configRoot) {
      return [normalize(configRoot)];
    }

    return rootNodes
      .sort((a, b) => a.path.localeCompare(b.path))
      .map(normalize);
  }

  async readFile(path: string): Promise<FileBuffer> {
    const entry = this.dataset.files[path];
    if (!entry) {
      throw new Error(`File not found: ${path}`);
    }
    return { path: entry.path, content: entry.content, mime: entry.mime, etag: entry.etag };
  }

  async writeFile(buffer: FileBuffer, options?: AdapterWriteOptions): Promise<FileBuffer> {
    const existing = this.dataset.files[buffer.path];
    if (options?.ifMatch && existing && existing.etag !== options.ifMatch) {
      throw new Error("File has been modified since last read.");
    }
    const etag = buildEtag();
    const entry: StoredFileEntry = {
      path: buffer.path,
      content: buffer.content,
      mime: buffer.mime,
      etag,
    };
    this.dataset = {
      files: {
        ...this.dataset.files,
        [buffer.path]: entry,
      },
    };
    this.persist();
    return { path: buffer.path, content: buffer.content, mime: buffer.mime, etag };
  }

  async renamePath(fromPath: string, toPath: string): Promise<void> {
    if (fromPath === toPath) {
      return;
    }
    if (this.dataset.files[toPath]) {
      throw new Error(`A file already exists at ${toPath}`);
    }
    const entry = this.dataset.files[fromPath];
    if (!entry) {
      throw new Error(`File not found: ${fromPath}`);
    }
    const updatedFiles = { ...this.dataset.files };
    delete updatedFiles[fromPath];
    updatedFiles[toPath] = {
      ...entry,
      path: toPath,
      mime: detectMimeFromPath(toPath),
      etag: buildEtag(),
    };
    this.dataset = { files: updatedFiles };
    this.persist();
  }

  async deletePath(path: string): Promise<void> {
    if (!this.dataset.files[path]) {
      throw new Error(`File not found: ${path}`);
    }
    const updatedFiles = { ...this.dataset.files };
    delete updatedFiles[path];
    this.dataset = { files: updatedFiles };
    this.persist();
  }

  async validate(target?: { readonly path?: string }): Promise<ValidationResult> {
    const problems: Problem[] = [];
    const logs: RunLogLine[] = [];
    const timestamp = nowIso();

    const inspectPath = target?.path ?? ROOT_PREFIX;
    logs.push({ ts: timestamp, text: `Validating ${inspectPath}` });

    Object.values(this.dataset.files).forEach((entry) => {
      if (target?.path && entry.path !== target.path) {
        return;
      }
      if (entry.content.includes("RAISE_ERROR")) {
        problems.push({
          path: entry.path,
          message: "Detected placeholder text 'RAISE_ERROR'. Remove it to clear this demo issue.",
          severity: "error",
          line: estimateLineNumber(entry.content, "RAISE_ERROR"),
        });
        logs.push({ ts: nowIso(), text: `Problem detected in ${entry.path}` });
      }
      if (entry.content.includes("TODO")) {
        problems.push({
          path: entry.path,
          message: "Contains TODO marker.",
          severity: "warning",
          line: estimateLineNumber(entry.content, "TODO"),
        });
      }
    });

    if (problems.length === 0) {
      logs.push({ ts: nowIso(), text: "Validation completed without issues." });
    } else {
      logs.push({ ts: nowIso(), text: `Validation finished with ${problems.length} issue(s).` });
    }

    return { problems, logs };
  }

  async run(target?: { readonly path?: string }): Promise<RunResult> {
    const logs: RunLogLine[] = [
      { ts: nowIso(), text: `Executing ${target?.path ?? "configuration"}…` },
      { ts: nowIso(), text: "Collecting inputs…" },
      { ts: nowIso(), text: "Run completed (demo)." },
    ];
    return { logs };
  }

  private readFromStorage(): StoredDataset | null {
    try {
      const storage = createScopedStorage(this.storageKey);
      return storage.get<StoredDataset>();
    } catch {
      return null;
    }
  }

  private persist() {
    const storage = createScopedStorage(this.storageKey);
    storage.set(this.dataset);
  }
}

function buildEtag(): string {
  return `${Date.now().toString(16)}-${Math.random().toString(16).slice(2, 8)}`;
}

function nowIso(): string {
  return new Date().toISOString();
}

function estimateLineNumber(content: string, needle: string): number {
  const index = content.indexOf(needle);
  if (index === -1) {
    return 1;
  }
  return content.slice(0, index).split("\n").length;
}
